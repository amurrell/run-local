#!/usr/bin/env bash

## Use to extend the usage of the rl commmand

# Load any rl-* functions in the rl-funcs folder
if [ -d "$REPO_ROOT/$RL_FUNC_FOLDER" ]; then
  for file in "$REPO_ROOT/$RL_FUNC_FOLDER/rl-"*; do
    if [ -f "$file" ]; then
      # shellcheck source=/dev/null
      source "$file"
      # step_text "Loaded rl-extended function: $file"
    fi
  done
fi

# keep track of the extended commands for length
EXTENDED_COMMANDS=()

# see if rl-<$1> exists in rl-funcs/ folder, primary or disabled
get_extended_option_color() {
  local color='disabled'
  [ -f "$REPO_ROOT/$RL_FUNC_FOLDER/rl-$1" ] && color='primary'
  echo "$color"
}

make_extended_option(){
  local check=$1
  local command=$2
  local description=$3
  local color
  local trimmed_command
  color=$(get_extended_option_color "$check")
  #index is the length of the array
  index=${#EXTENDED_COMMANDS[@]} # Zero-based index
  index=$((index + 1)) # One-based index
  trimmed_command=$(echo "$command" | xargs) # Trim leading/trailing whitespace
  # if color==disabled, append -disabled to the command
  if [ "$color" == "disabled" ]; then
    trimmed_command="$trimmed_command [disabled]"
    description="· Add rl-funcs/rl-$check to enable"
  fi
  EXTENDED_COMMANDS+=("$trimmed_command")
  # Adjust the displayed index to be one-based (index + 1)

  # if color == disabled, use color_text with each one to make it disabled
  # do not use pretty option
  if [ "$color" == "disabled" ]; then
    pretty_option "$(color_text disabled "e$index) $command $description" disabled)"
  else
    pretty_option "$(color_text "$color" "e$index)")" "$command" "$description"
  fi
}

show_help_extended() {
  color_text faint "RL-Extended (Custom) Commands: "
  echo ""
  # the $check vs $command is for the file it comes from, eg. check "artisan" to get both artisan and debug-artisan commands
  make_extended_option "post-install" "post-install   " "· Run post-install commands"
  make_extended_option "composer"     "composer       " "· Run a Composer command"
  make_extended_option "artisan"      "artisan        " "· Run an Artisan command"
  make_extended_option "artisan"      "debug-artisan  " "· Run an Artisan command with Xdebug enabled (port $XDEBUG_CLI_PORT)"
  make_extended_option "tinker"       "tinker         " "· Run Tinker (Laravel REPL)"
  make_extended_option "tinker"       "debug-tinker   " "· Run Tinker with Xdebug enabled (port $XDEBUG_CLI_PORT)"
  make_extended_option "assets"       "assets-download" ". Download assets folder via ssh into tar.gz in DockerLocal/data"
  make_extended_option "assets"       "assets         " ". Checks DockerLocal/data for .tar.gz files, swaps/backs up current uploads"
  echo ""
}

handle_rl_extended() {
  # Determine the script to run based on the first argument
  case $1 in
    post-install)
      post_install
      exit $?
      ;;
    composer)
      # need everything after the first argument (eg. update --lock)
      run_composer_command "${*:2}"
      exit 0
      ;;
    artisan)
      prompt_artisan_command "$@"
      # need everything after the first argument (eg. route:list)
      run_artisan_command "${*:2}"
      exit 0
      ;;
    debug-artisan)
      prompt_artisan_command "$@"
      run_debug_artisan_command "${*:2}"
      exit 0
      ;;
    tinker)
      run_tinker_command
      exit 0
      ;;
    debug-tinker)
      run_debug_tinker_command
      exit 0
      ;;
    assets-download)
      assets_download
      exit 0
      ;;
    assets)
      assets_upload
      exit 0
      ;;
    *)
      echo "Unknown (extended) command: $1"
      exit 1
      ;;
  esac
}

handle_rl_extended_choice() {
  local choice="$1"

  # Exit gracefully on empty input
  if [ -z "$choice" ]; then
    step_text "No option chosen... Quitting."
    exit 0
  fi

  # Load commands if not already loaded
  if [ ${#EXTENDED_COMMANDS[@]} -eq 0 ]; then
    show_help_extended > /dev/null
  fi

  # e# format (e.g. e1, e2)
  if [[ "$choice" =~ ^e([0-9]+)$ ]]; then
    local index="${BASH_REMATCH[1]}"
    local array_index=$((index - 1))

    if [[ $array_index -ge 0 && $array_index -lt ${#EXTENDED_COMMANDS[@]} ]]; then
      local command="${EXTENDED_COMMANDS[$array_index]}"

      if [[ "$command" == *"[disabled]"* ]]; then
        step_text "Command is disabled. Enable it in rl-funcs/ folder."
        exit 0
      fi

      step_text "Executing command: $command"
      ./run-local "$command"
      return
    else
      step_text "No (valid) $choice option chosen... Quitting."
      exit 0
    fi
  fi

  # Try fallback match by command name
  for extended_cmd in "${EXTENDED_COMMANDS[@]}"; do
    base_cmd=$(echo "$extended_cmd" | cut -d' ' -f1) # handle possible [disabled]
    if [[ "$base_cmd" == "$choice" ]]; then
      if [[ "$extended_cmd" == *"[disabled]"* ]]; then
        step_text "Command is disabled. Enable it in rl-funcs/ folder."
        exit 0
      fi

      step_text "Executing command: $base_cmd"
      ./run-local "$base_cmd"
      return
    fi
  done

  # Nothing matched
  step_text "Unknown extended command: $choice"
  exit 1
}

show_extended_command_names() {
  # Load commands if not already loaded
  if [ ${#EXTENDED_COMMANDS[@]} -eq 0 ]; then
    show_help_extended > /dev/null
  fi

  for cmd in "${EXTENDED_COMMANDS[@]}"; do
    echo "$cmd" | cut -d' ' -f1 | sed 's/\[disabled\]//'
  done
}
